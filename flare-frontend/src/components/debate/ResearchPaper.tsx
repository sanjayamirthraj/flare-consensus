"use client";

import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { CardHeader, CardTitle } from "@/components/ui/card";
import { ResearchPaperResponse } from "@/services/debateService";
import jsPDF from 'jspdf';
import { ArrowUp } from 'lucide-react';

interface ResearchPaperProps {
  paperData: ResearchPaperResponse;
  isOpen: boolean;
  onClose: () => void;
  topic: string;
}

// Add an interface for section types to improve navigation
interface Section {
  id: string;
  label: string;
}

// Define sections for easier navigation
const sections: Section[] = [
  { id: 'all', label: 'Full Paper' },
  { id: 'abstract', label: 'Abstract' },
  { id: 'introduction', label: 'Introduction' },
  { id: 'perspectives', label: 'Perspectives' },
  { id: 'discussion', label: 'Discussion' },
  { id: 'conclusion', label: 'Conclusion' },
  { id: 'references', label: 'References' },
];

export function ResearchPaper({ paperData, isOpen, onClose, topic }: ResearchPaperProps) {
  const [selectedSection, setSelectedSection] = useState<string>("all");
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [showScrollTop, setShowScrollTop] = useState<boolean>(false);
  const contentRef = useRef<HTMLDivElement>(null);
  const sectionRefs = useRef<Record<string, HTMLElement | null>>({});
  
  // Initialize section refs
  useEffect(() => {
    // Reset section refs when paper changes
    sectionRefs.current = sections.reduce((acc, section) => {
      acc[section.id] = null;
      return acc;
    }, {} as Record<string, HTMLElement | null>);
  }, [paperData]);
  
  // Reset section selection when paper changes
  useEffect(() => {
    setSelectedSection("all");
  }, [paperData]);
  
  // Scroll to section when selectedSection changes
  useEffect(() => {
    if (selectedSection !== 'all' && sectionRefs.current[selectedSection]) {
      sectionRefs.current[selectedSection]?.scrollIntoView({ 
        behavior: 'smooth',
        block: 'start'
      });
    } else if (selectedSection === 'all' && contentRef.current) {
      contentRef.current.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }, [selectedSection]);
  
  // Handle scroll events to show/hide scroll-to-top button
  useEffect(() => {
    const handleScroll = () => {
      if (contentRef.current) {
        setShowScrollTop(contentRef.current.scrollTop > 300);
      }
    };
    
    const contentElement = contentRef.current;
    if (contentElement) {
      contentElement.addEventListener('scroll', handleScroll);
      return () => contentElement.removeEventListener('scroll', handleScroll);
    }
  }, []);
  
  // Scroll to top function
  const scrollToTop = () => {
    if (contentRef.current) {
      contentRef.current.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
  };
  
  if (!isOpen) return null;
  
  const formatSection = (text: string) => {
    if (!text) return <p className="text-gray-500 italic">No content available</p>;
    
    return text.split('\n').map((paragraph, index) => (
      <p key={index} className={`${index > 0 ? "mt-4" : ""} leading-relaxed text-gray-700`}>
        {paragraph}
      </p>
    ));
  };

  const handleExport = async () => {
    setIsLoading(true);
    
    try {
      if (!contentRef.current) {
        throw new Error("Content ref is not available");
      }
      
      // Create a new jsPDF instance (A4 paper, portrait orientation)
      const pdf = new jsPDF('p', 'mm', 'a4');
      
      // Define PDF dimensions
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();
      const margin = 10; // margin in mm
      
      // Add title
      pdf.setFontSize(18);
      pdf.setTextColor(40);
      pdf.text(paperData.title || `Research Analysis: ${topic}`, margin, margin + 10);
      
      // Add footer with attribution
      pdf.setFontSize(8);
      pdf.setTextColor(150, 150, 150);
      pdf.text(`Generated by Marckarimi • ${new Date().toLocaleDateString()}`, margin, margin + 18);
      
      // Start content position
      let yPosition = margin + 25;
      
      // Helper function to add a section to the PDF
      const addSectionToPdf = (title: string, content: string) => {
        // Add section title
        pdf.setFontSize(14);
        pdf.setTextColor(40);
        pdf.text(title, margin, yPosition);
        yPosition += 7;
        
        // Add section content
        pdf.setFontSize(12);
        pdf.setTextColor(80);
        
        // Split text into paragraphs
        const paragraphs = content.split('\n').filter(p => p.trim().length > 0);
        
        paragraphs.forEach(paragraph => {
          // Split paragraph into lines that fit on the page
          const textLines = pdf.splitTextToSize(paragraph, pdfWidth - (margin * 2));
          
          // Check if we need a new page
          if (yPosition + (textLines.length * 6) > pdfHeight - margin) {
            pdf.addPage();
            yPosition = margin + 10;
          }
          
          // Add lines to PDF
          pdf.text(textLines, margin, yPosition);
          yPosition += (textLines.length * 6) + 5;
        });
        
        // Add space after section
        yPosition += 5;
      };
      
      // Add Abstract
      addSectionToPdf("Abstract", paperData.abstract);
      
      // Add Introduction if available
      if (paperData.introduction) {
        addSectionToPdf("Introduction", paperData.introduction);
      }
      
      // Add Perspectives
      if (paperData.perspectives.length > 0) {
        // Section title
        pdf.setFontSize(14);
        pdf.setTextColor(40);
        pdf.text("Perspectives", margin, yPosition);
        yPosition += 7;
        
        // Each perspective
        paperData.perspectives.forEach((perspective) => {
          // Check if we need a new page
          if (yPosition > pdfHeight - 40) {
            pdf.addPage();
            yPosition = margin + 10;
          }
          
          // Perspective title
          pdf.setFontSize(13);
          pdf.setTextColor(60);
          pdf.text(`${perspective.stance} Perspective`, margin, yPosition);
          yPosition += 6;
          
          // Perspective content
          pdf.setFontSize(12);
          pdf.setTextColor(80);
          
          // Split text into paragraphs
          const paragraphs = perspective.content.split('\n').filter(p => p.trim().length > 0);
          
          paragraphs.forEach(paragraph => {
            // Split paragraph into lines that fit on the page
            const textLines = pdf.splitTextToSize(paragraph, pdfWidth - (margin * 2));
            
            // Check if we need a new page
            if (yPosition + (textLines.length * 6) > pdfHeight - margin) {
              pdf.addPage();
              yPosition = margin + 10;
            }
            
            // Add lines to PDF
            pdf.text(textLines, margin, yPosition);
            yPosition += (textLines.length * 6) + 5;
          });
          
          // Add space after perspective
          yPosition += 5;
        });
      }
      
      // Add Discussion if available
      if (paperData.discussion) {
        addSectionToPdf("Discussion", paperData.discussion);
      }
      
      // Add Conclusion if available
      if (paperData.conclusion) {
        addSectionToPdf("Conclusion", paperData.conclusion);
      }
      
      // Add References if available
      if (paperData.references.length > 0) {
        // Section title
        pdf.setFontSize(14);
        pdf.setTextColor(40);
        pdf.text("References", margin, yPosition);
        yPosition += 7;
        
        // Each reference
        pdf.setFontSize(11);
        pdf.setTextColor(80);
        
        paperData.references.forEach((reference, index) => {
          // Split reference into lines that fit on the page
          const textLines = pdf.splitTextToSize(`${index + 1}. ${reference}`, pdfWidth - (margin * 2));
          
          // Check if we need a new page
          if (yPosition + (textLines.length * 5) > pdfHeight - margin) {
            pdf.addPage();
            yPosition = margin + 10;
          }
          
          // Add lines to PDF
          pdf.text(textLines, margin, yPosition);
          yPosition += (textLines.length * 5) + 3;
        });
      }
      
      // Save the PDF
      pdf.save(`Research_Paper-${topic.replace(/\s+/g, '_')}.pdf`);
    } catch (error) {
      console.error("Error generating PDF:", error);
      alert("There was an error generating the PDF. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  
  const sectionNav = (
    <div className="flex flex-wrap gap-2 pb-2">
      {sections.map((section) => (
        <Button
          key={section.id}
          variant="ghost"
          size="sm"
          className={`text-sm ${selectedSection === section.id ? 'bg-[#E71D73]/10 text-[#E71D73] hover:bg-[#E71D73]/20' : 'hover:bg-gray-100'}`}
          onClick={() => setSelectedSection(section.id)}
        >
          {section.label}
        </Button>
      ))}
    </div>
  );
  
  const renderContent = () => {
    if (selectedSection === 'all') {
      return (
        <div className="space-y-8">
          {/* Abstract */}
          <section 
            className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
            ref={(el) => { sectionRefs.current.abstract = el; }}
            id="abstract"
          >
            <h3 className="text-xl font-bold mb-4 text-gray-800">Abstract</h3>
            <div className="text-gray-700">{formatSection(paperData.abstract)}</div>
          </section>
          
          {/* Introduction */}
          {paperData.introduction && (
            <section 
              className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
              ref={(el) => { sectionRefs.current.introduction = el; }}
              id="introduction"
            >
              <h3 className="text-xl font-bold mb-4 text-gray-800">Introduction</h3>
              <div className="text-gray-700">{formatSection(paperData.introduction)}</div>
            </section>
          )}
          
          {/* Perspectives */}
          {paperData.perspectives.length > 0 && (
            <section 
              className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
              ref={(el) => { sectionRefs.current.perspectives = el; }}
              id="perspectives"
            >
              <h3 className="text-xl font-bold mb-4 text-gray-800">Perspectives</h3>
              <div className="space-y-6">
                {paperData.perspectives.map((perspective, index) => (
                  <div key={index} className="border-l-4 border-[#E71D73]/30 pl-4 py-2">
                    <h4 className="text-lg font-semibold mb-2 text-gray-800">{perspective.stance} Perspective</h4>
                    <div className="text-gray-700">{formatSection(perspective.content)}</div>
                  </div>
                ))}
              </div>
            </section>
          )}
          
          {/* Discussion */}
          {paperData.discussion && (
            <section 
              className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
              ref={(el) => { sectionRefs.current.discussion = el; }}
              id="discussion"
            >
              <h3 className="text-xl font-bold mb-4 text-gray-800">Discussion</h3>
              <div className="text-gray-700">{formatSection(paperData.discussion)}</div>
            </section>
          )}
          
          {/* Conclusion */}
          {paperData.conclusion && (
            <section 
              className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
              ref={(el) => { sectionRefs.current.conclusion = el; }}
              id="conclusion"
            >
              <h3 className="text-xl font-bold mb-4 text-gray-800">Conclusion</h3>
              <div className="text-gray-700">{formatSection(paperData.conclusion)}</div>
            </section>
          )}
          
          {/* References */}
          {paperData.references.length > 0 && (
            <section 
              className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
              ref={(el) => { sectionRefs.current.references = el; }}
              id="references"
            >
              <h3 className="text-xl font-bold mb-4 text-gray-800">References</h3>
              <ul className="list-decimal list-inside space-y-2 text-gray-700">
                {paperData.references.map((reference, index) => (
                  <li key={index} className="ml-4 pl-2">{reference}</li>
                ))}
              </ul>
            </section>
          )}
        </div>
      );
    }
    
    // Render individual sections
    const renderSectionContent = (title: string, content: string | string[] | any[], sectionId: string) => (
      <section 
        className="bg-white p-6 rounded-lg border border-gray-100 shadow-sm scroll-mt-[120px]"
        ref={(el) => { sectionRefs.current[sectionId] = el; }}
        id={sectionId}
      >
        <h3 className="text-xl font-bold mb-4 text-gray-800">{title}</h3>
        {Array.isArray(content) && title === "References" ? (
          <ul className="list-decimal list-inside space-y-2 text-gray-700">
            {content.map((item, index) => (
              <li key={index} className="ml-4 pl-2">{item}</li>
            ))}
          </ul>
        ) : Array.isArray(content) ? (
          <div className="space-y-6">
            {content.map((item, index) => (
              <div key={index} className="border-l-4 border-[#E71D73]/30 pl-4 py-2">
                <h4 className="text-lg font-semibold mb-2 text-gray-800">{item.stance} Perspective</h4>
                <div className="text-gray-700">{formatSection(item.content)}</div>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-gray-700">{formatSection(content as string)}</div>
        )}
      </section>
    );
    
    switch (selectedSection) {
      case 'abstract':
        return renderSectionContent("Abstract", paperData.abstract, "abstract");
      case 'introduction':
        return renderSectionContent("Introduction", paperData.introduction, "introduction");
      case 'perspectives':
        return renderSectionContent("Perspectives", paperData.perspectives, "perspectives");
      case 'discussion':
        return renderSectionContent("Discussion", paperData.discussion, "discussion");
      case 'conclusion':
        return renderSectionContent("Conclusion", paperData.conclusion, "conclusion");
      case 'references':
        return renderSectionContent("References", paperData.references, "references");
      default:
        return null;
    }
  };
  
  return (
    <motion.div 
      className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4 overflow-hidden"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={(e) => {
        // Close when clicking backdrop, but not when clicking the content
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
    >
      <motion.div 
        className="w-full max-w-5xl h-[90vh] bg-gray-50 rounded-xl shadow-xl flex flex-col overflow-hidden"
        initial={{ scale: 0.9, y: 20 }}
        animate={{ scale: 1, y: 0 }}
        transition={{ type: "spring", damping: 25, stiffness: 300 }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex flex-col h-full w-full">
          {/* Fixed header */}
          <div className="border-b bg-white z-30 sticky top-0 shrink-0">
            <CardHeader className="flex flex-row justify-between items-center pb-4">
              <div>
                <CardTitle className="text-2xl font-bold text-gray-900">
                  {paperData.title || `Research Analysis: ${topic}`}
                </CardTitle>
                <div className="text-xs text-gray-400 mt-4 text-center">
                  Generated by Marckarimi • {new Date().toLocaleDateString()}
                </div>
              </div>
              <div className="flex space-x-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={onClose}
                  className="hover:bg-gray-100"
                >
                  Close
                </Button>
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={handleExport}
                  disabled={isLoading}
                  className="border-[#E71D73]/30 text-[#E71D73] hover:bg-[#E71D73]/5"
                >
                  {isLoading ? (
                    <span className="flex items-center">
                      <span className="mr-2 inline-block w-2 h-2 bg-[#E71D73] rounded-full animate-ping"></span>
                      Generating PDF...
                    </span>
                  ) : (
                    "Export as PDF"
                  )}
                </Button>
              </div>
            </CardHeader>
          </div>
          
          {/* Section navigation */}
          <div className="bg-white z-20 sticky top-[73px] px-6 pt-3 pb-2 border-b shrink-0">
            {sectionNav}
          </div>
          
          {/* Scrollable content */}
          <div 
            className="flex-grow overflow-y-auto custom-scrollbar p-6 relative"
            ref={contentRef}
          >
            <div className="paper-content">
              {renderContent()}
            </div>
            
            {/* Scroll to top button */}
            <AnimatePresence>
              {showScrollTop && (
                <motion.button
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: 10 }}
                  onClick={scrollToTop}
                  className="fixed bottom-6 right-6 bg-[#E71D73] text-white p-2 rounded-full shadow-lg hover:bg-[#D61A6A] transition-colors z-30"
                  aria-label="Scroll to top"
                >
                  <ArrowUp size={20} />
                </motion.button>
              )}
            </AnimatePresence>
          </div>
        </div>
      </motion.div>
    </motion.div>
  );
} 